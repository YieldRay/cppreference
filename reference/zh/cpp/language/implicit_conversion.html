<!DOCTYPE html>
<html lang="zh" dir="ltr" class="client-nojs">
<head>
<title>隐式转换</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.21.2">
<link rel="shortcut icon" href="../../../common/favicon.ico">
<link rel="stylesheet" href="../../../common/ext.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<link rel="stylesheet" href="../../../common/site_modules.css">
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}#toc{display:none}.editsection{display:none}
/* cache key: mwiki1-mwiki_zh_:resourceloader:filter:minify-css:7:15cea3ec788a65b5187d4018eed543bf */</style>

<script src="../../../common/startup_scripts.js"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"cpp/language/implicit_conversion","wgTitle":"cpp/language/implicit conversion","wgCurRevisionId":93568,"wgArticleId":2722,"wgIsArticle":true,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":false,"wgPageContentLanguage":"zh","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"zh","wgMonthNames":["","1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"],"wgMonthNamesShort":["","1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"],"wgRelevantPageName":"cpp/language/implicit_conversion","wgUserVariant":"zh","wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function(){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":0,"showtoolbar":1,"skin":"cppreference2","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,
"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"zh","language":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"gadget-MathJax":1,"gadget-ColiruCompiler":1});;},{},{});mw.loader.implement("user.tokens",function(){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});;},{},{});
/* cache key: mwiki1-mwiki_zh_:resourceloader:filter:minify-js:7:258d7cd6aa9aa67dee25e01fb6a9e505 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax"]);
}</script>
<style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000dd;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #909090;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es1 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es2 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es3 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es4 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es5 {color: #008000; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #008000;}
.cpp.source-cpp .nu0 {color: #000080;}
.cpp.source-cpp .nu6 {color: #000080;}
.cpp.source-cpp .nu8 {color: #000080;}
.cpp.source-cpp .nu12 {color: #000080;}
.cpp.source-cpp .nu16 {color:#000080;}
.cpp.source-cpp .nu17 {color:#000080;}
.cpp.source-cpp .nu18 {color:#000080;}
.cpp.source-cpp .nu19 {color:#000080;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-cpp_language_implicit_conversion skin-cppreference2 action-view cpp-navbar">
        <!-- header -->
        <!-- /header -->
        <!-- content -->
<div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8HW0LXMYCY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8HW0LXMYCY');
</script>
                <h1 id="firstHeading" class="firstHeading">隐式转换</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    <div id="siteSub">来自cppreference.com</div>
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    <div id="contentSub"><span class="subpages">&lt; <a href="../../cpp.html" title="cpp">cpp</a>‎ | <a href="../language.html" title="cpp/language">language</a></span></div>
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div id="mw-content-text" lang="zh" dir="ltr" class="mw-content-ltr"><p><br>
</p>
<div class="t-navbar" style=""><div class="t-navbar-sep"> </div><div class="t-navbar-head"><a href="../../cpp.html" title="cpp"> C++</a><div class="t-navbar-menu"><div><div><table class="t-nv-begin" cellpadding="0" style="line-height:1.1em;">
<tr class="t-nv"><td colspan="5"> <a href="../compiler_support.html" title="cpp/compiler support"> 编译器支持</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../freestanding.html" title="cpp/freestanding"> 自立实现与有宿主实现</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../language.html" title="cpp/language">语言</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../standard_library.html" title="cpp/standard library">标准库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../headers.html" title="cpp/header">标准库标头</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../named_req.html" title="cpp/named req">具名要求</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../feature_test.html" title="cpp/feature test"> 功能特性测试宏 </a> <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../utility.html#.E8.AF.AD.E8.A8.80.E6.94.AF.E6.8C.81" title="cpp/utility">语言支持库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../concepts.html" title="cpp/concepts">概念库</a> <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../meta.html" title="cpp/meta"> 元编程库</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../error.html" title="cpp/error">诊断库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../utility.html" title="cpp/utility">通用工具库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../string.html" title="cpp/string">字符串库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../container.html" title="cpp/container">容器库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../iterator.html" title="cpp/iterator">迭代器库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../ranges.html" title="cpp/ranges"> 范围库</a> <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../algorithm.html" title="cpp/algorithm">算法库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../numeric.html" title="cpp/numeric">数值库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../locale.html" title="cpp/locale">本地化库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../io.html" title="cpp/io">输入/输出库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../filesystem.html" title="cpp/filesystem">文件系统库</a> <span class="t-mark-rev t-since-cxx17">(C++17)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../regex.html" title="cpp/regex">正则表达式库</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../thread.html" title="cpp/thread">并发支持库</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../experimental.html" title="cpp/experimental">技术规范</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../symbol_index.html" title="cpp/symbol index"> 符号索引</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../links/libs.html" title="cpp/links/libs"> 外部库</a> </td></tr>
</table></div><div></div></div></div></div><div class="t-navbar-sep"> </div><div class="t-navbar-head"><a href="../language.html" title="cpp/language">C++ 语言</a><div class="t-navbar-menu"><div><div style="display:inline-block">
<div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv-h1"><td colspan="5">一般主题</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="../preprocessor.html" title="cpp/preprocessor">预处理器</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../comments.html" title="cpp/comment">注释</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="../keywords.html" title="cpp/keyword">关键词</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="escape.html" title="cpp/language/escape">转义序列</a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h1"><td colspan="5"><a href="statements.html" title="cpp/language/statements">流程控制</a></td></tr>
<tr class="t-nv-h2"><td colspan="5">条件执行语句</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="if.html" title="cpp/language/if"><tt>if</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="switch.html" title="cpp/language/switch"><tt>switch</tt></a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5">重复语句（循环）</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="for.html" title="cpp/language/for"><tt>for</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="range-for.html" title="cpp/language/range-for">范围 <span class="mw-geshi cpp source-cpp"><span class="kw1">for</span></span></a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="while.html" title="cpp/language/while"><tt>while</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="do.html" title="cpp/language/do"><code>do-while</code></a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5">跳转语句</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="continue.html" title="cpp/language/continue"><tt>continue</tt></a> - <a href="break.html" title="cpp/language/break"><tt>break</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="goto.html" title="cpp/language/goto"><tt>goto</tt></a> - <a href="return.html" title="cpp/language/return"><tt>return</tt></a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h1"><td colspan="5"><a href="functions.html" title="cpp/language/functions">函数</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="function.html" title="cpp/language/function">函数声明</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="lambda.html" title="cpp/language/lambda">lambda 函数表达式</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="inline.html" title="cpp/language/inline"><span class="mw-geshi cpp source-cpp"><span class="kw1">inline</span></span> 说明符</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="except_spec.html" title="cpp/language/except spec">动态异常说明</a> <span class="t-mark">(<span title="C++11 中弃用">C++17 前*</span>)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="noexcept_spec.html" title="cpp/language/noexcept spec"><span class="mw-geshi cpp source-cpp"><span class="kw1">noexcept</span></span> 说明符</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
<tr class="t-nv-h1"><td colspan="5">异常</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="throw.html" title="cpp/language/throw"><span class="mw-geshi cpp source-cpp"><span class="kw1">throw</span></span> 表达式</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="try.html" title="cpp/language/try"><span class="mw-geshi cpp source-cpp"><span class="kw1">try</span></span> 块</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <br>
</td></tr>
<tr class="t-nv"><td colspan="5"><a href="catch.html" title="cpp/language/catch">处理块</a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h1"><td colspan="5">命名空间</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="namespace.html" title="cpp/language/namespace">命名空间声明</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="namespace_alias.html" title="cpp/language/namespace alias">命名空间别名</a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h1"><td colspan="5">类型</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="types.html" title="cpp/language/types">基础类型</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="enum.html" title="cpp/language/enum">枚举类型</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="function.html" title="cpp/language/function">函数类型</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="class.html" title="cpp/language/class">类/结构体类型</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="union.html" title="cpp/language/union">联合体类型</a></td></tr>
<tr class="t-nv"><td colspan="5"> <br>
</td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5">说明符</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="cv.html" title="cpp/language/cv"><span class="mw-geshi cpp source-cpp"><span class="kw4">const</span></span>/<span class="mw-geshi cpp source-cpp"><span class="kw4">volatile</span></span></a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="decltype.html" title="cpp/language/decltype"><tt>decltype</tt></a> <span class="t-mark-rev t-since-cxx11">(C++11)</span>  </td></tr>
<tr class="t-nv"><td colspan="5"><a href="auto.html" title="cpp/language/auto"><tt>auto</tt></a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="constexpr.html" title="cpp/language/constexpr"><tt>constexpr</tt></a> <span class="t-mark-rev t-since-cxx11">(C++11)</span>  </td></tr>
<tr class="t-nv"><td colspan="5"><a href="consteval.html" title="cpp/language/consteval"><tt>consteval</tt></a> <span class="t-mark-rev t-since-cxx20">(C++20)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="constinit.html" title="cpp/language/constinit"><tt>constinit</tt></a> <span class="t-mark-rev t-since-cxx20">(C++20)</span></td></tr>
</table></div></td></tr>
<tr class="t-nv"><td colspan="5"><a href="storage_duration.html" title="cpp/language/storage duration">存储期说明符</a></td></tr>
<tr class="t-nv-h2"><td colspan="5"><a href="initialization.html" title="cpp/language/initialization">初始化</a></td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="default_initialization.html" title="cpp/language/default initialization">默认初始化</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="value_initialization.html" title="cpp/language/value initialization">值初始化</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="zero_initialization.html" title="cpp/language/zero initialization">零初始化</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="copy_initialization.html" title="cpp/language/copy initialization">复制初始化</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="direct_initialization.html" title="cpp/language/direct initialization">直接初始化</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="aggregate_initialization.html" title="cpp/language/aggregate initialization">聚合初始化</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="list_initialization.html" title="cpp/language/list initialization">列表初始化</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="constant_initialization.html" title="cpp/language/constant initialization">常量初始化</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="reference_initialization.html" title="cpp/language/reference initialization">引用初始化</a></td></tr>
<tr class="t-nv"><td colspan="5"> <br>
</td></tr>
</table></div></td></tr>
</table></div>
</div>
<div style="display:inline-block">
<div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv-h1"><td colspan="5"><a href="expressions.html" title="cpp/language/expressions">表达式</a></td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="value_category.html" title="cpp/language/value category">值类别</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="eval_order.html" title="cpp/language/eval order">求值顺序</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="operators.html" title="cpp/language/operators">运算符</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="operator_precedence.html" title="cpp/language/operator precedence">运算符优先级</a></td></tr>
</table></div></td></tr>
<tr class="t-nv"><td colspan="5"><a href="operator_alternative.html" title="cpp/language/operator alternative">替代表示</a></td></tr>
<tr class="t-nv-h2"><td colspan="5"><a href="expressions.html#.E5.AD.97.E9.9D.A2.E9.87.8F" title="cpp/language/expressions">字面量</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="bool_literal.html" title="cpp/language/bool literal">布尔</a> - <a href="integer_literal.html" title="cpp/language/integer literal">整数</a> - <a href="floating_literal.html" title="cpp/language/floating literal">浮点</a></td></tr>   
<tr class="t-nv"><td colspan="5"><a href="character_literal.html" title="cpp/language/character literal">字符</a> - <a href="string_literal.html" title="cpp/language/string literal">字符串</a> - <a href="nullptr.html" title="cpp/language/nullptr"><tt>nullptr</tt></a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr> 
<tr class="t-nv"><td colspan="5"><a href="user_literal.html" title="cpp/language/user literal">用户定义</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
<tr class="t-nv-h1"><td colspan="5">工具</td></tr>
<tr class="t-nv"><td colspan="5"><a href="attributes.html" title="cpp/language/attributes">属性</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
<tr class="t-nv-h2"><td colspan="5">类型</td></tr>
<tr class="t-nv"><td colspan="5"><a href="typedef.html" title="cpp/language/typedef"><code>typedef</code> 声明</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="type_alias.html" title="cpp/language/type alias">类型别名声明</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
<tr class="t-nv-h2"><td colspan="5">类型转换</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><strong class="selflink">隐式转换</strong></td></tr>
<tr class="t-nv"><td colspan="5"><a href="static_cast.html" title="cpp/language/static cast"><tt>static_cast</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="const_cast.html" title="cpp/language/const cast"><tt>const_cast</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="explicit_cast.html" title="cpp/language/explicit cast">显式转换</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="dynamic_cast.html" title="cpp/language/dynamic cast"><tt>dynamic_cast</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="reinterpret_cast.html" title="cpp/language/reinterpret cast"><tt>reinterpret_cast</tt></a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5">内存分配</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="new.html" title="cpp/language/new"><code>new</code> 表达式</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="delete.html" title="cpp/language/delete"><code>delete</code> 表达式</a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h1"><td colspan="5"><a href="classes.html" title="cpp/language/classes">类</a></td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="class.html" title="cpp/language/class">类声明</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="initializer_list.html" title="cpp/language/constructor">构造函数</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="this.html" title="cpp/language/this"><code>this</code> 指针</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="access.html" title="cpp/language/access">访问说明符</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="friend.html" title="cpp/language/friend"><span class="mw-geshi cpp source-cpp"><span class="kw1">friend</span></span> 说明符</a></td></tr>
<tr class="t-nv"><td colspan="5"> <br>
</td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5">类特有的函数性质</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="virtual.html" title="cpp/language/virtual">虚函数</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="override.html" title="cpp/language/override"><span class="mw-geshi cpp source-cpp">override</span> 说明符</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span>  </td></tr>
<tr class="t-nv"><td colspan="5"><a href="final.html" title="cpp/language/final"><span class="mw-geshi cpp source-cpp">final</span> 说明符</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="explicit.html" title="cpp/language/explicit"><tt>explicit</tt></a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="static.html" title="cpp/language/static"><tt>static</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <br>
</td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5">特殊成员函数</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="default_constructor.html" title="cpp/language/default constructor">默认构造函数</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="copy_constructor.html" title="cpp/language/copy constructor">复制构造函数</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="move_constructor.html" title="cpp/language/move constructor">移动构造函数</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="as_operator.html" title="cpp/language/copy assignment">复制赋值</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="move_assignment.html" title="cpp/language/move assignment">移动赋值</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="destructor.html" title="cpp/language/destructor">析构函数</a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h1"><td colspan="5"><a href="templates.html" title="cpp/language/templates">模板</a></td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="class_template.html" title="cpp/language/class template">类模板</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="function_template.html" title="cpp/language/function template">函数模板</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="template_specialization.html" title="cpp/language/template specialization">模板特化</a></td></tr>   
<tr class="t-nv"><td colspan="5"><a href="parameter_pack.html" title="cpp/language/parameter pack">形参包</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
</table></div></td></tr>
<tr class="t-nv-h1"><td colspan="5">杂项</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="asm.html" title="cpp/language/asm">内联汇编</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="history.html" title="cpp/language/history">C++ 的历史</a></td></tr>
</table></div></td></tr>
</table></div>
</div><div></div></div></div></div><div class="t-navbar-sep"> </div><div class="t-navbar-head"><a href="expressions.html" title="cpp/language/expressions"> 表达式</a><div class="t-navbar-menu"><div><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv-h2"><td colspan="5">概述</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="value_category.html" title="cpp/language/value category">值类别</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="eval_order.html" title="cpp/language/eval order">求值顺序</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="constant_expression.html" title="cpp/language/constant expression">常量表达式</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="expressions.html#.E5.88.9D.E7.AD.89.E8.A1.A8.E8.BE.BE.E5.BC.8F" title="cpp/language/expressions">初等表达式</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="lambda.html" title="cpp/language/lambda">lambda 表达式</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="requires.html" title="cpp/language/requires">requires 表达式</a> <span class="t-mark-rev t-since-cxx20">(C++20)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="pack_indexing.html#.E5.8C.85.E7.B4.A2.E5.BC.95.E8.A1.A8.E8.BE.BE.E5.BC.8F" title="cpp/language/pack indexing">包索引表达式</a> <span class="t-mark-rev t-since-cxx26">(C++26)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="expressions.html#.E6.BD.9C.E5.9C.A8.E6.B1.82.E5.80.BC.E8.A1.A8.E8.BE.BE.E5.BC.8F" title="cpp/language/expressions">潜在求值表达式</a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5">字面量</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="integer_literal.html" title="cpp/language/integer literal">整数字面量</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="floating_literal.html" title="cpp/language/floating literal">浮点字面量</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="bool_literal.html" title="cpp/language/bool literal">布尔字面量</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="character_literal.html" title="cpp/language/character literal">字符字面量</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="escape.html" title="cpp/language/escape">转义序列</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="string_literal.html" title="cpp/language/string literal">字符串字面量</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="nullptr.html" title="cpp/language/nullptr">空指针字面量</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="user_literal.html" title="cpp/language/user literal">用户定义字面量</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5">运算符</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="operator_assignment.html" title="cpp/language/operator assignment">赋值运算符</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="operator_incdec.html" title="cpp/language/operator incdec">自增与自减</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="operator_arithmetic.html" title="cpp/language/operator arithmetic">算术运算符</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="operator_logical.html" title="cpp/language/operator logical">逻辑运算符</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="operator_comparison.html" title="cpp/language/operator comparison">比较运算符</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="operator_member_access.html" title="cpp/language/operator member access">成员访问运算符</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="operator_other.html" title="cpp/language/operator other">其他运算符</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="new.html" title="cpp/language/new"><code>new</code> 表达式</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="delete.html" title="cpp/language/delete"><code>delete</code> 表达式</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="throw.html" title="cpp/language/throw"><code>throw</code> 表达式</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="alignof.html" title="cpp/language/alignof"><code>alignof</code></a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="sizeof.html" title="cpp/language/sizeof"><code>sizeof</code></a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="sizeof....html" title="cpp/language/sizeof..."><code>sizeof...</code></a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="typeid.html" title="cpp/language/typeid"><code>typeid</code></a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="noexcept.html" title="cpp/language/noexcept"><code>noexcept</code></a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="fold.html" title="cpp/language/fold">折叠表达式</a> <span class="t-mark-rev t-since-cxx17">(C++17)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="operator_alternative.html" title="cpp/language/operator alternative">运算符的代用表示</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="operator_precedence.html" title="cpp/language/operator precedence">优先级和结合性</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="operators.html" title="cpp/language/operators">运算符重载</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="default_comparisons.html" title="cpp/language/default comparisons">预置比较</a> <span class="t-mark-rev t-since-cxx20">(C++20)</span></td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5">类型转换</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><strong class="selflink">隐式转换</strong></td></tr>
<tr class="t-nv"><td colspan="5"><a href="explicit_cast.html" title="cpp/language/explicit cast">显式转换</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="usual_arithmetic_conversions.html" title="cpp/language/usual arithmetic conversions">一般算术转换</a>    </td></tr>
<tr class="t-nv"><td colspan="5"><a href="cast_operator.html" title="cpp/language/cast operator">用户定义转换</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="const_cast.html" title="cpp/language/const cast"><code>const_cast</code></a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="static_cast.html" title="cpp/language/static cast"><code>static_cast</code></a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="dynamic_cast.html" title="cpp/language/dynamic cast"><code>dynamic_cast</code></a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="reinterpret_cast.html" title="cpp/language/reinterpret cast"><code>reinterpret_cast</code></a></td></tr>
</table></div></td></tr>
</table></div><div></div></div></div></div><div class="t-navbar-sep"> </div></div>
<p>凡是在语境中使用了某种类型 <code>T1</code> 的表达式，但语境不接受该类型而接受另一类型 <code>T2</code> 的时候，会进行隐式转换；具体是：
</p>
<ul><li> 调用以 <code>T2</code> 为形参声明的函数时，以该表达式作为实参；
</li><li> 运算符期待 <code>T2</code>，而以该表达式作为操作数；
</li><li> 初始化 <code>T2</code> 类型的新对象，包括在返回 <code>T2</code> 的函数中的 <code>return</code> 语句；
</li><li> 将表达式用于 <span class="mw-geshi cpp source-cpp"><span class="kw1">switch</span></span> 语句（<code>T2</code> 是整数类型）；
</li><li> 将表达式用于 <span class="mw-geshi cpp source-cpp"><span class="kw1">if</span></span> 语句或循环（<code>T2</code> 是 <span class="mw-geshi cpp source-cpp"><span class="kw4">bool</span></span>）。
</li></ul>
<p>仅当存在一个从 <code>T1</code> 到 <code>T2</code> 的无歧义<i>隐式转换序列</i> ﻿时，程序良构（能编译）。
</p><p>如果所调用的函数或运算符存在多个重载，那么将 <code>T1</code> 到每个可用的 <code>T2</code> 都构造隐式转化序列之后，会以<a href="overload_resolution.html" title="cpp/language/overload resolution">重载决议</a>规则决定编译哪个重载。
</p><p>注意：算术表达式中，针对二元运算符的操作数上的隐式转换的目标类型，是以一组单独的<a href="usual_arithmetic_conversions.html" title="cpp/language/usual arithmetic conversions">一般算术转换</a>的规则所决定的。
</p>
<h3><span class="mw-headline" id=".E8.BD.AC.E6.8D.A2.E9.A1.BA.E5.BA.8F">转换顺序</span></h3>
<p>隐式转换序列由下列内容依照这个顺序所构成：
</p>
<div class="t-li1"><span class="t-li">1)</span> 零或一个<i>标准转换序列</i>；</div>
<div class="t-li1"><span class="t-li">2)</span> 零或一个<i>用户定义转换</i>；</div>
<div class="t-li1"><span class="t-li">3)</span> 零或一个<i>标准转换序列</i>（仅在使用用户定义转换时适用）。</div>
<p>当考虑构造函数或用户定义转换函数的实参时，只允许一个标准转换序列（否则可以将用户定义转换有效地串连起来）。当从一个非类类型转换到另一非类类型时，只允许一个标准转换序列。
</p><p>标准转换序列由下列内容依照这个顺序所构成：
</p>
<div class="t-li1"><span class="t-li">1)</span> 下列转换中的零或一个：
<ul><li> <i>左值到右值转换</i>
</li><li> <i>数组到指针转换</i>
</li><li> <i>函数到指针转换</i></li></ul></div>

<div class="t-li1"><span class="t-li">2)</span> 零或一个<i>数值提升</i> ﻿或<i>数值转换</i></div>
<table class="t-rev-begin">
<tr class="t-rev t-since-cxx17"><td>
<div class="t-li1"><span class="t-li">3)</span> 零或一个<i>函数指针转换</i></div>
</td>
<td><span class="t-mark-rev t-since-cxx17">(C++17 起)</span></td></tr>
</table>
<div class="t-li1"><span class="t-li">4)</span> 零或一个<i>限定转换</i></div>
<p>用户定义转换由零或一个非显式单实参<a href="converting_constructor.html" title="cpp/language/converting constructor">转换构造函数</a>或非显式<a href="cast_operator.html" title="cpp/language/cast operator">转换函数</a>的调用构成。
</p><p>当且仅当 <code>T2</code> 能从表达式 <span class="t-c"><span class="mw-geshi cpp source-cpp">e</span></span> <a href="copy_initialization.html" title="cpp/language/copy initialization">复制初始化</a>，即对于虚设的临时对象 <span class="t-c"><span class="mw-geshi cpp source-cpp">t</span></span>，声明 <span class="t-c"><span class="mw-geshi cpp source-cpp">T2 t <span class="sy1">=</span> e<span class="sy4">;</span></span></span> 良构（能编译）时，称表达式 <span class="t-c"><span class="mw-geshi cpp source-cpp">e</span></span> <i>可隐式转换到 <code>T2</code></i>。注意这与<a href="direct_initialization.html" title="cpp/language/direct initialization">直接初始化</a>（<span class="t-c"><span class="mw-geshi cpp source-cpp">T2 t<span class="br0">(</span>e<span class="br0">)</span></span></span>）不同，其中还会额外考虑显式构造函数和转换函数。
</p>
<h4><span class="mw-headline" id=".E6.8C.89.E8.AF.AD.E5.A2.83.E8.BD.AC.E6.8D.A2">按语境转换</span></h4>
<table class="t-rev-begin">
<tr class="t-rev t-since-cxx11"><td>
<p>下列语境中，期待类型 <span class="mw-geshi cpp source-cpp"><span class="kw4">bool</span></span>，且如果声明 <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">bool</span> t<span class="br0">(</span>e<span class="br0">)</span><span class="sy4">;</span></span></span> 良构就会进行隐式转换（即考虑如 <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">explicit</span> T<span class="sy4">::</span><span class="me2">operator</span> <span class="kw4">bool</span><span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span><span class="sy4">;</span></span></span> 这样的 <span class="mw-geshi cpp source-cpp"><span class="kw1">explicit</span></span>
转换函数）。称这种表达式 <span class="t-c"><span class="mw-geshi cpp source-cpp">e</span></span> <i>按语境转换到 <span class="mw-geshi cpp source-cpp"><span class="kw4">bool</span></span></i>。
</p>
<ul><li> <span class="mw-geshi cpp source-cpp"><span class="kw1">if</span></span>、<span class="mw-geshi cpp source-cpp"><span class="kw1">while</span></span>、<span class="mw-geshi cpp source-cpp"><span class="kw1">for</span></span> 的控制表达式；
</li><li> 内建逻辑运算符 <code>!</code>、<code>&amp;&amp;</code> 和 <code>||</code> 的操作数；
</li><li> 条件运算符 <code>?:</code> 的首个操作数；
</li><li> <a href="static_assert.html" title="cpp/language/static assert"><code>static_assert</code></a> 声明中的谓词；
</li><li> <a href="noexcept_spec.html" title="cpp/language/noexcept spec"><code>noexcept</code></a> 说明符中的表达式；
</li></ul>
<table class="t-rev-begin">
<tr class="t-rev t-since-cxx20"><td>
<ul><li> <a href="explicit.html" title="cpp/language/explicit"><code>explicit</code></a> 说明符中的表达式。
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx20">(C++20 起)</span></td></tr>
</table>
</td>
<td><span class="t-mark-rev t-since-cxx11">(C++11 起)</span></td></tr>
</table>
<p>下列语境中，期待某个语境特定的类型 <code>T</code>，只有满足以下条件才能使用具有类类型 <code>E</code> 的表达式 <span class="t-c"><span class="mw-geshi cpp source-cpp">e</span></span>：
</p>
<table class="t-rev-begin">
<tr class="t-rev t-until-cxx14"><td>
<ul><li> <code>E</code> 拥有单个转换到任何可允许类型的<span class="t-rev-inl t-since-cxx11"><span>非显式</span> <span><span class="t-mark-rev t-since-cxx11">(C++11 起)</span></span></span><a href="cast_operator.html" title="cpp/language/cast operator">用户定义转换函数</a>。
</li></ul>
</td>
<td><span class="t-mark-rev t-until-cxx14">(C++14 前)</span></td></tr>
<tr class="t-rev t-since-cxx14"><td>
<ul><li> 可允许类型中恰好有一个类型 <code>T</code>，使得 <code>E</code> 拥有非显式转换函数，它的返回类型是（可有 cv 限定的）<code>T</code> 或到（可有 cv 限定的）<code>T</code> 的引用的，且
</li><li> <span class="t-c"><span class="mw-geshi cpp source-cpp">e</span></span> 可隐式转换到 <code>T</code>。
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx14">(C++14 起)</span></td></tr>
</table>
<p>称这种表达式 <span class="t-c"><span class="mw-geshi cpp source-cpp">e</span></span> <i>按语境隐式转换</i> ﻿到指定的类型 <code>T</code>。<span class="t-rev-inl t-since-cxx11"><span>注意，其中不考虑显式转换函数，虽然在按语境转换到 <span class="mw-geshi cpp source-cpp"><span class="kw4">bool</span></span> 时会考虑它们。</span> <span><span class="t-mark-rev t-since-cxx11">(C++11 起)</span></span></span>
</p>
<ul><li> <a href="delete.html" title="cpp/language/delete">delete 表达式</a>的实参（<code>T</code> 是任意对象指针类型）；
</li><li> <a href="constant_expression.html#.E6.95.B4.E6.95.B0.E5.B8.B8.E9.87.8F.E8.A1.A8.E8.BE.BE.E5.BC.8F" title="cpp/language/constant expression">整数常量表达式</a>，其中使用了字面类（<code>T</code> 是任意整数或<span class="t-rev-inl t-since-cxx11"><span>无作用域</span> <span><span class="t-mark-rev t-since-cxx11">(C++11 起)</span></span></span>枚举类型，所选中的用户定义转换函数必须是 <a href="constexpr.html" title="cpp/language/constexpr">constexpr</a>）；
</li><li> <a href="switch.html" title="cpp/language/switch"><code>switch</code></a> 语句的控制表达式（<code>T</code> 是任意整数或枚举类型）。
</li></ul>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;cassert&gt;</span>
 
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw1">class</span> zero_init
<span class="br0">{</span>
    T val<span class="sy4">;</span>
<span class="kw1">public</span><span class="sy4">:</span>
    zero_init<span class="br0">(</span><span class="br0">)</span> <span class="sy4">:</span> val<span class="br0">(</span><span class="kw1">static_cast</span><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
    zero_init<span class="br0">(</span>T val<span class="br0">)</span> <span class="sy4">:</span> val<span class="br0">(</span>val<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
    operator T<span class="sy3">&amp;</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> val<span class="sy4">;</span> <span class="br0">}</span>
    operator T<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> val<span class="sy4">;</span> <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    zero_init<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> i<span class="sy4">;</span>
    <a href="../error/assert.html"><span class="kw776">assert</span></a><span class="br0">(</span>i <span class="sy1">==</span> <span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span>
 
    i <span class="sy1">=</span> <span class="nu0">7</span><span class="sy4">;</span>
    <a href="../error/assert.html"><span class="kw776">assert</span></a><span class="br0">(</span>i <span class="sy1">==</span> <span class="nu0">7</span><span class="br0">)</span><span class="sy4">;</span>
 
    <span class="kw1">switch</span> <span class="br0">(</span>i<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>     <span class="co1">// C++14 前错误（多于一个转换函数）</span>
                      <span class="co1">// C++14 起 OK（两个函数均转换到同一类型 int）</span>
    <span class="kw1">switch</span> <span class="br0">(</span>i <span class="sy2">+</span> <span class="nu0">0</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span> <span class="co1">// 始终 OK（隐式转换）</span>
<span class="br0">}</span></pre></div></div>
<h3><span class="mw-headline" id=".E5.80.BC.E5.8F.98.E6.8D.A2">值变换</span></h3>
<p>值变换是更改表达式<a href="value_category.html" title="cpp/language/value category">值类别</a>的转换。每当将表达式用作期待不同值类别的表达式的运算符的操作数时，发生值变换：
</p>
<ul><li> 对于某个要求纯右值作为它的操作数的运算符，每当泛左值被用作操作数，都会对该表达式应用<i>左值到右值</i>，<i>数组到指针</i>，或者<i>函数到指针</i> ﻿标准转换以将它转换成纯右值。
</li></ul>
<table class="t-rev-begin">
<tr class="t-rev t-since-cxx17"><td>
<ul><li> 对于某个期待泛左值作为它的操作数的运算符，每当纯右值被用作操作数，都会应用<i>临时量实质化</i> ﻿将该表达式转换成亡值。
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx17">(C++17 起)</span></td></tr>
</table>
<h4><span class="mw-headline" id=".E5.B7.A6.E5.80.BC.E5.88.B0.E5.8F.B3.E5.80.BC.E8.BD.AC.E6.8D.A2">左值到右值转换</span></h4>
<p>任何非函数、非数组类型 <code>T</code> 的<span class="t-rev-inl t-until-cxx11"><span><a href="value_category.html#.E5.B7.A6.E5.80.BC" title="cpp/language/value category">左值</a></span> <span><span class="t-mark-rev t-until-cxx11">(C++11 前)</span></span></span><span class="t-rev-inl t-since-cxx11"><span><a href="value_category.html#.E6.B3.9B.E5.B7.A6.E5.80.BC" title="cpp/language/value category">泛左值</a></span> <span><span class="t-mark-rev t-since-cxx11">(C++11 起)</span></span></span>都可以转换成<span class="t-rev-inl t-until-cxx11"><span><a href="value_category.html#.E5.8F.B3.E5.80.BC" title="cpp/language/value category">右值</a></span> <span><span class="t-mark-rev t-until-cxx11">(C++11 前)</span></span></span><span class="t-rev-inl t-since-cxx11"><span><a href="value_category.html#.E7.BA.AF.E5.8F.B3.E5.80.BC" title="cpp/language/value category">纯右值</a></span> <span><span class="t-mark-rev t-since-cxx11">(C++11 起)</span></span></span>：
</p>
<ul><li> 如果 <code>T</code> 不是类类型，那么<span class="t-rev-inl t-until-cxx11"><span>右值</span> <span><span class="t-mark-rev t-until-cxx11">(C++11 前)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>纯右值</span> <span><span class="t-mark-rev t-since-cxx11">(C++11 起)</span></span></span>的类型是 <code>T</code> 的无 cv 限定版本。
</li><li> 否则<span class="t-rev-inl t-until-cxx11"><span>右值</span> <span><span class="t-mark-rev t-until-cxx11">(C++11 前)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>纯右值</span> <span><span class="t-mark-rev t-since-cxx11">(C++11 起)</span></span></span>的类型是 <code>T</code>。
</li></ul>
<p>如果程序要求从<a href="incomplete_type.html#.E4.B8.8D.E5.AE.8C.E6.95.B4.E7.B1.BB.E5.9E.8B" title="cpp/language/type">不完整类型</a>进行左值到右值转换，那么该程序非良构。
</p>
<table class="t-rev-begin">
<tr class="t-rev t-until-cxx11"><td>
<p>当左值到右值转换在 <a href="sizeof.html" title="cpp/language/sizeof"><code>sizeof</code></a> 的操作数内发生时，不会访问被引用的对象中包含的值，因为该运算符<a href="expressions.html#.E6.BD.9C.E5.9C.A8.E6.B1.82.E5.80.BC.E8.A1.A8.E8.BE.BE.E5.BC.8F" title="cpp/language/expressions">不会</a>对它的操作数求值。
</p>
</td>
<td><span class="t-mark-rev t-until-cxx11">(C++11 前)</span></td></tr>
<tr class="t-rev t-since-cxx11"><td>
<p>当对表达式 <span class="t-c"><span class="mw-geshi cpp source-cpp">E</span></span> 应用左值到右值转换时，在以下情况下不会访问被引用的对象中包含的值：
</p>
<ul><li> <span class="t-c"><span class="mw-geshi cpp source-cpp">E</span></span> 不会<a href="expressions.html#.E6.BD.9C.E5.9C.A8.E6.B1.82.E5.80.BC.E8.A1.A8.E8.BE.BE.E5.BC.8F" title="cpp/language/expressions">被潜在求值</a>，或者
</li><li> 对 <span class="t-c"><span class="mw-geshi cpp source-cpp">E</span></span> 的求值会导致对 <span class="t-c"><span class="mw-geshi cpp source-cpp">E</span></span> 的<a href="definition.html#ODR_.E4.BD.BF.E7.94.A8" title="cpp/language/definition">潜在结果</a>集合中的某个成员 <span class="t-c"><span class="mw-geshi cpp source-cpp">Ex</span></span> 求值，并且 <span class="t-c"><span class="mw-geshi cpp source-cpp">Ex</span></span> 命名了某个 <span class="t-c"><span class="mw-geshi cpp source-cpp">Ex</span></span> 自身没有 <a href="definition.html#ODR_.E4.BD.BF.E7.94.A8" title="cpp/language/definition">ODR 使用</a>的变量 <span class="t-c"><span class="mw-geshi cpp source-cpp">x</span></span>。
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx11">(C++11 起)</span></td></tr>
</table>
<p><br>
</p>
<table class="t-rev-begin">
<tr class="t-rev t-until-cxx11"><td>
<p>转换的结果是该左值表示的对象包含的值。
</p>
</td>
<td><span class="t-mark-rev t-until-cxx11">(C++11 前)</span></td></tr>
<tr class="t-rev t-since-cxx11"><td>
<p>转换的结果根据以下规则确定：
</p>
<ul><li> 如果 <code>T</code> 是（可能有 cv 限定的）<span class="t-lc"><a href="../types/nullptr_t.html" title="cpp/types/nullptr t">std::nullptr_t</a></span>，那么结果是<a href="pointer.html#.E7.A9.BA.E6.8C.87.E9.92.88" title="cpp/language/pointer">空指针值</a>。因为转换不会访问该泛左值指代的对象，所以即使在 <code>T</code> 有 volatile 限定的情况下也不会有副作用，并且该泛左值可以指代联合体的非活跃成员。
</li><li> 否则，如果 <code>T</code> 具有类类型，那么：
</li></ul>
<table class="t-rev-begin">
<tr class="t-rev t-until-cxx17"><td>
<dl><dd><ul><li> 转换会从该泛左值<a href="copy_initialization.html" title="cpp/language/copy initialization">复制初始化</a>一个 <code>T</code> 类型的<a href="lifetime.html#.E4.B8.B4.E6.97.B6.E5.AF.B9.E8.B1.A1.E7.9A.84.E7.94.9F.E5.AD.98.E6.9C.9F" title="cpp/language/lifetime">临时量</a>，并且转换结果是此临时量的纯右值。
</li></ul>
</dd></dl>
</td>
<td><span class="t-mark-rev t-until-cxx17">(C++17 前)</span></td></tr>
<tr class="t-rev t-since-cxx17"><td>
<dl><dd><ul><li> 转换会从该泛左值<a href="copy_initialization.html" title="cpp/language/copy initialization">复制初始化</a>一个<a href="implicit_cast.html#.E4.B8.B4.E6.97.B6.E9.87.8F.E5.AE.9E.E8.B4.A8.E5.8C.96">结果对象</a>。
</li></ul>
</dd></dl>
</td>
<td><span class="t-mark-rev t-since-cxx17">(C++17 起)</span></td></tr>
</table>
<ul><li> 否则，如果该泛左值指代的对象包含的是一个无效指针值，那么行为由实现定义。
</li><li> 否则，<span class="t-rev-inl t-since-cxx20"><span>读取该泛左值表示的对象，而</span> <span><span class="t-mark-rev t-since-cxx20">(C++20 起)</span></span></span>结果是该对象包含的值。
</li></ul>
<table class="t-rev-begin">
<tr class="t-rev t-since-cxx26"><td>
<dl><dd><ul><li> 如果结果是<a href="default_initialization.html#.E4.B8.8D.E7.A1.AE.E5.AE.9A.E5.80.BC.E5.92.8C.E9.94.99.E8.AF.AF.E5.80.BC" title="cpp/language/default initialization">错误值</a>，并且<a href="object.html#.E5.AF.B9.E8.B1.A1.E8.A1.A8.E7.A4.BA.E4.B8.8E.E5.80.BC.E8.A1.A8.E7.A4.BA" title="cpp/language/object">值表示</a>中包含的位对于该对象的类型非法，那么行为未定义。
</li></ul>
</dd></dl>
</td>
<td><span class="t-mark-rev t-since-cxx26">(C++26 起)</span></td></tr>
</table>
</td>
<td><span class="t-mark-rev t-since-cxx11">(C++11 起)</span></td></tr>
</table>
<p>这项转换塑造的是从某个内存位置中读取值到 CPU 寄存器之中的动作。
</p>
<h4><span class="mw-headline" id=".E6.95.B0.E7.BB.84.E5.88.B0.E6.8C.87.E9.92.88.E8.BD.AC.E6.8D.A2">数组到指针转换</span></h4>
<p>“<code>T</code> 的 <code>N</code> 元素数组”或“<code>T</code> 的未知边界数组”类型的<a href="value_category.html#.E5.B7.A6.E5.80.BC" title="cpp/language/value category">左值</a>或<a href="value_category.html#.E5.8F.B3.E5.80.BC" title="cpp/language/value category">右值</a>，可隐式转换成“指向 <code>T</code> 的指针”类型的<a href="value_category.html#.E7.BA.AF.E5.8F.B3.E5.80.BC" title="cpp/language/value category">纯右值</a>。<span class="t-rev-inl t-since-cxx17"><span>如果数组是纯右值，那么就会发生<a href="implicit_cast.html#.E4.B8.B4.E6.97.B6.E9.87.8F.E5.AE.9E.E8.B4.A8.E5.8C.96">临时量实质化</a>。</span> <span><span class="t-mark-rev t-since-cxx17">(C++17 起)</span></span></span>产生的指针指向数组首元素（细节参阅<a href="array.html#.E6.95.B0.E7.BB.84.E5.88.B0.E6.8C.87.E9.92.88.E9.80.80.E5.8C.96" title="cpp/language/array">数组到指针退化</a>）。
</p>
<h4><span class="mw-headline" id=".E5.87.BD.E6.95.B0.E5.88.B0.E6.8C.87.E9.92.88.E8.BD.AC.E6.8D.A2">函数到指针转换</span></h4>
<p><span id=".E5.87.BD.E6.95.B0.E5.88.B0.E6.8C.87.E9.92.88"></span>
函数类型的<a href="value_category.html#.E5.B7.A6.E5.80.BC" title="cpp/language/value category">左值</a>，可隐式转换成<a href="pointer.html#.E5.87.BD.E6.95.B0.E6.8C.87.E9.92.88" title="cpp/language/pointer">指向该函数的指针</a>的<a href="value_category.html#.E7.BA.AF.E5.8F.B3.E5.80.BC" title="cpp/language/value category">纯右值</a>。这不适用于非静态成员函数，因为不存在指代非静态成员函数的左值。
</p>
<table class="t-rev-begin">
<tr class="t-rev t-since-cxx17"><td>
<h4> <span class="mw-headline" id=".E4.B8.B4.E6.97.B6.E9.87.8F.E5.AE.9E.E8.B4.A8.E5.8C.96">临时量实质化</span></h4>
<p>任何完整类型 <code>T</code> 的<a href="value_category.html#.E7.BA.AF.E5.8F.B3.E5.80.BC" title="cpp/language/value category">纯右值</a>，可转换成同类型 <code>T</code> 的亡值。此转换以该纯右值初始化一个 T 类型的<a href="lifetime.html#.E4.B8.B4.E6.97.B6.E5.AF.B9.E8.B1.A1.E7.94.9F.E5.AD.98.E6.9C.9F" title="cpp/language/lifetime">临时对象</a>（以临时对象作为求值该纯右值的结果对象），并产生一个代表该临时对象的亡值。
</p><p>如果 <code>T</code> 是类类型或类类型的数组，那么它必须有可访问且未被弃置的析构函数：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> S <span class="br0">{</span> <span class="kw4">int</span> m<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
<span class="kw4">int</span> k <span class="sy1">=</span> S<span class="br0">(</span><span class="br0">)</span>.<span class="me1">m</span><span class="sy4">;</span> <span class="co1">// C++17 起成员访问期待泛左值；</span>
               <span class="co1">// S() 纯右值被转换成亡值</span></pre></div></div>
<p>临时量实质化在下例情况下发生：
</p>
<ul><li> <a href="reference_initialization.html" title="cpp/language/reference initialization">绑定引用</a>到纯右值时；
</li><li> <a href="operator_member_access.html" title="cpp/language/operator member access">访问</a>类纯右值的<a href="data_members.html" title="cpp/language/data members">数据成员</a>时；
</li><li> <a href="operator_other.html#.E5.86.85.E5.BB.BA.E7.9A.84.E5.87.BD.E6.95.B0.E8.B0.83.E7.94.A8.E8.BF.90.E7.AE.97.E7.AC.A6" title="cpp/language/operator other">调用</a>类纯右值的<a href="member_functions.html" title="cpp/language/member functions">隐式对象成员函数</a>时；
</li><li> 进行数组到指针转换（见上文）或在数组纯右值上<a href="operator_member_access.html#.E5.86.85.E5.BB.BA.E7.9A.84.E4.B8.8B.E6.A0.87.E8.BF.90.E7.AE.97.E7.AC.A6" title="cpp/language/operator member access">使用下标</a>时；
</li><li> 以<a href="list_initialization.html" title="cpp/language/list initialization">花括号初始化器列表</a>初始化 <span class="mw-geshi cpp source-cpp"><a href="../utility/initializer_list.html"><span class="kw962">std::<span class="me2">initializer_list</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span></span> 类型的对象时；
</li><li> 纯右值作为<a href="expressions.html#.E5.BC.83.E5.80.BC.E8.A1.A8.E8.BE.BE.E5.BC.8F" title="cpp/language/expressions">弃值表达式</a>时；
</li></ul>
<p>注意临时量实质化在从纯右值初始化同类型对象（由<a href="direct_initialization.html" title="cpp/language/direct initialization">直接初始化</a>或<a href="copy_initialization.html" title="cpp/language/copy initialization">复制初始化</a>）时<b>不会</b>发生：这种对象直接从初始化器初始化。这确保了“受保证的复制消除”。
</p>
</td>
<td><span class="t-mark-rev t-since-cxx17">(C++17 起)</span></td></tr>
</table>
<h3><span class="mw-headline" id=".E6.95.B4.E6.95.B0.E6.8F.90.E5.8D.87">整数提升</span></h3>
<p>小整数类型（如 <span class="mw-geshi cpp source-cpp"><span class="kw4">char</span></span>）和无作用域枚举类型的<a href="value_category.html#.E7.BA.AF.E5.8F.B3.E5.80.BC" title="cpp/language/value category">纯右值</a>可转换成较大整数类型（如 <span class="mw-geshi cpp source-cpp"><span class="kw4">int</span></span>）的纯右值。具体而言，<a href="operator_arithmetic.html" title="cpp/language/operator arithmetic">算术运算符</a>不接受小于 <span class="mw-geshi cpp source-cpp"><span class="kw4">int</span></span> 的类型作为它的实参，而在左值到右值转换后，如果适用就会自动实施整数提升。此转换始终保持原值。
</p><p>本段中的以下隐式转换被归类为<i>整数提升</i>。
</p>
<h4><span class="mw-headline" id=".E4.BB.8E.E6.95.B4.E6.95.B0.E7.B1.BB.E5.9E.8B.E6.8F.90.E5.8D.87">从整数类型提升</span></h4>
<p><span class="mw-geshi cpp source-cpp"><span class="kw4">bool</span></span> 类型的纯右值可转换成 <span class="mw-geshi cpp source-cpp"><span class="kw4">int</span></span> 类型的纯右值，值 <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw2">false</span></span></span> 变为 <span class="t-c"><span class="mw-geshi cpp source-cpp">​<span class="nu0">0</span>​</span></span> 而 <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw2">true</span></span></span> 变为 <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="nu0">1</span></span></span>。
</p><p>对于 <span class="mw-geshi cpp source-cpp"><span class="kw4">bool</span></span> 以外的整数类型 <code>T</code> 的纯右值 <span class="t-c"><span class="mw-geshi cpp source-cpp">val</span></span>：
</p>
<div class="t-li1"><span class="t-li">1)</span> 如果 <span class="t-c"><span class="mw-geshi cpp source-cpp">val</span></span> 是对<a href="bit_field.html" title="cpp/language/bit field">位域</a>应用左值到右值转换的结果，那么
<ul><li> 在 <span class="mw-geshi cpp source-cpp"><span class="kw4">int</span></span> 可以表示该位域的所有值的情况下，<span class="t-c"><span class="mw-geshi cpp source-cpp">val</span></span> 可以转换成 <span class="mw-geshi cpp source-cpp"><span class="kw4">int</span></span> 类型的纯右值，
</li><li> 否则在 <span class="mw-geshi cpp source-cpp"><span class="kw4">unsigned</span> <span class="kw4">int</span></span> 可以表示该位域的所有值的情况下，<span class="t-c"><span class="mw-geshi cpp source-cpp">val</span></span> 可以转换成 <span class="mw-geshi cpp source-cpp"><span class="kw4">unsigned</span> <span class="kw4">int</span></span> 类型的纯右值，
</li><li> 否则 <span class="t-c"><span class="mw-geshi cpp source-cpp">val</span></span> 可以按照第 (3) 项中的规则进行转换。</li></ul></div>

<div class="t-li1"><span class="t-li">2)</span> 否则（<span class="t-c"><span class="mw-geshi cpp source-cpp">val</span></span> 不是从位域转换而来），
<ul><li> 如果 <code>T</code> 是 <span class="t-rev-inl t-since-cxx20"><span><span class="mw-geshi cpp source-cpp">char8_t</span>，</span> <span><span class="t-mark-rev t-since-cxx20">(C++20 起)</span></span></span><span class="t-rev-inl t-since-cxx11"><span><span class="mw-geshi cpp source-cpp"><span class="kw4">char16_t</span></span>，<span class="mw-geshi cpp source-cpp"><span class="kw4">char32_t</span></span> 或 </span> <span><span class="t-mark-rev t-since-cxx11">(C++11 起)</span></span></span><span class="mw-geshi cpp source-cpp"><span class="kw4">wchar_t</span></span>，那么 <span class="t-c"><span class="mw-geshi cpp source-cpp">val</span></span> 可以按照第 (3) 项中的规则进行转换；
</li><li> 否则，如果 <code>T</code> 的<a href="usual_arithmetic_conversions.html#.E6.95.B4.E6.95.B0.E8.BD.AC.E6.8D.A2.E7.AD.89.E7.BA.A7" title="cpp/language/usual arithmetic conversions">整数转换等级</a>低于 <span class="mw-geshi cpp source-cpp"><span class="kw4">int</span></span> 的整数转换等级，那么
</li></ul>
<dl><dd><ul><li> 在 <span class="mw-geshi cpp source-cpp"><span class="kw4">int</span></span> 可以表示 <code>T</code> 的所有值的情况下，<span class="t-c"><span class="mw-geshi cpp source-cpp">val</span></span> 可以转换成 <span class="mw-geshi cpp source-cpp"><span class="kw4">int</span></span> 类型的纯右值，
</li><li> 否则，<span class="t-c"><span class="mw-geshi cpp source-cpp">val</span></span> 可以转换成 <span class="mw-geshi cpp source-cpp"><span class="kw4">unsigned</span> <span class="kw4">int</span></span> 类型的纯右值。</li></ul></dd></dl></div>


<div class="t-li1"><span class="t-li">3)</span> 在第 (1) 项（无法适配 <span class="mw-geshi cpp source-cpp"><span class="kw4">unsigned</span> <span class="kw4">int</span></span> 的转换后位域）和第 (2) 项（<code>T</code> 是指定的字符类型之一）指定的情况下，<span class="t-c"><span class="mw-geshi cpp source-cpp">val</span></span> 可转换到以下列表中首个可以表示它的所有值的类型：
<ul><li> <span class="mw-geshi cpp source-cpp"><span class="kw4">int</span></span>
</li><li> <span class="mw-geshi cpp source-cpp"><span class="kw4">unsigned</span> <span class="kw4">int</span></span>
</li><li> <span class="mw-geshi cpp source-cpp"><span class="kw4">long</span></span>
</li><li> <span class="mw-geshi cpp source-cpp"><span class="kw4">unsigned</span> <span class="kw4">long</span></span>
</li></ul>
<table class="t-rev-begin">
<tr class="t-rev t-since-cxx11"><td>
<ul><li> <span class="mw-geshi cpp source-cpp"><span class="kw4">long</span> <span class="kw4">long</span></span>
</li><li> <span class="mw-geshi cpp source-cpp"><span class="kw4">unsigned</span> <span class="kw4">long</span> <span class="kw4">long</span></span>
</li><li> <code>T</code> 的底层类型
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx11">(C++11 起)</span></td></tr>
</table></div>
<h4><span class="mw-headline" id=".E4.BB.8E.E6.9E.9A.E4.B8.BE.E7.B1.BB.E5.9E.8B.E6.8F.90.E5.8D.87">从枚举类型提升</span></h4>
<p>底层类型不固定的无作用域<a href="enum.html" title="cpp/language/enum">枚举</a>类型可转换到以下列表中首个可以表示它的所有值的类型：
</p>
<ul><li> <span class="mw-geshi cpp source-cpp"><span class="kw4">int</span></span>
</li><li> <span class="mw-geshi cpp source-cpp"><span class="kw4">unsigned</span> <span class="kw4">int</span></span>
</li><li> <span class="mw-geshi cpp source-cpp"><span class="kw4">long</span></span>
</li><li> <span class="mw-geshi cpp source-cpp"><span class="kw4">unsigned</span> <span class="kw4">long</span></span>
</li></ul>
<table class="t-rev-begin">
<tr class="t-rev t-since-cxx11"><td>
<ul><li> <span class="mw-geshi cpp source-cpp"><span class="kw4">long</span> <span class="kw4">long</span></span>
</li><li> <span class="mw-geshi cpp source-cpp"><span class="kw4">unsigned</span> <span class="kw4">long</span> <span class="kw4">long</span></span>
</li><li> 满足以下要求的<a href="types.html#.E6.89.A9.E5.B1.95.E6.95.B4.E6.95.B0.E7.B1.BB.E5.9E.8B" title="cpp/language/types">扩展整数类型</a>：
</li></ul>
<dl><dd><ul><li> 该类型的<a href="usual_arithmetic_conversions.html#.E6.95.B4.E6.95.B0.E8.BD.AC.E6.8D.A2.E7.AD.89.E7.BA.A7" title="cpp/language/usual arithmetic conversions">整数转换等级</a>大于 <span class="mw-geshi cpp source-cpp"><span class="kw4">long</span> <span class="kw4">long</span></span> 整数转换等级。
</li><li> 该类型的整数转换等级在扩展整数类型中最低。
</li><li> 在扩展整数类型中整数转换等级最低的类型有两个时，该类型有符号。
</li></ul>
</dd></dl>
</td>
<td><span class="t-mark-rev t-since-cxx11">(C++11 起)</span></td></tr>
</table>
<p><br>
</p>
<table class="t-rev-begin">
<tr class="t-rev t-since-cxx11"><td>
<p>底层类型固定的无作用域枚举类型可转换到它的底层类型。进而，当底层类型也适用整数提升时，那么也可以转换到提升后的底层类型。对于<a href="overload_resolution.html" title="cpp/language/overload resolution">重载决议</a>，到未提升的底层类型的转换更佳。
</p>
</td>
<td><span class="t-mark-rev t-since-cxx11">(C++11 起)</span></td></tr>
</table>
<p>注意，所有其他转换都不是提升；例如<a href="overload_resolution.html" title="cpp/language/overload resolution">重载决议</a>选择 <span class="mw-geshi cpp source-cpp"><span class="kw4">char</span></span> -&gt; <span class="mw-geshi cpp source-cpp"><span class="kw4">int</span></span>（提升）优先于 <span class="mw-geshi cpp source-cpp"><span class="kw4">char</span></span> -&gt; <span class="mw-geshi cpp source-cpp"><span class="kw4">short</span></span>（转换）。
</p>
<h3><span class="mw-headline" id=".E6.B5.AE.E7.82.B9.E6.8F.90.E5.8D.87">浮点提升</span></h3>
<p><span class="mw-geshi cpp source-cpp"><span class="kw4">float</span></span> 类型<a href="value_category.html#.E7.BA.AF.E5.8F.B3.E5.80.BC" title="cpp/language/value category">纯右值</a>可转换成 <span class="mw-geshi cpp source-cpp"><span class="kw4">double</span></span> 类型的纯右值。值不会更改。
</p><p>该转换被称为<i>浮点提升</i>。
</p>
<h3><span class="mw-headline" id=".E6.95.B0.E5.80.BC.E8.BD.AC.E6.8D.A2">数值转换</span></h3>
<p>不同于提升，数值转换可以更改值，而且有潜在的精度损失。
</p>
<h4><span class="mw-headline" id=".E6.95.B4.E6.95.B0.E8.BD.AC.E6.8D.A2">整数转换</span></h4>
<p>整数类型或<span class="t-rev-inl t-since-cxx11"><span>无作用域</span> <span><span class="t-mark-rev t-since-cxx11">(C++11 起)</span></span></span>枚举类型的<a href="value_category.html#.E7.BA.AF.E5.8F.B3.E5.80.BC" title="cpp/language/value category">纯右值</a>都可隐式转换成任何其他整数类型。如果该转换列在“整数类型提升”下，那么它是提升而非转换。
</p>
<ul><li> 如果目标类型无符号，那么结果值是等于源值<a href="https://en.wikipedia.org/wiki/Modular_arithmetic" class="extiw" title="enwiki:Modular arithmetic">模</a> <span class="texhtml" style="white-space: nowrap;">2<span class="t-su">n<br></span></span> 的最小无符号值，其中 <span class="texhtml" style="white-space: nowrap;">n</span> 用来表示目标类型的位数。
</li></ul>
<dl><dd><ul><li> 即，取决于目标类型更宽或更窄，分别对有符号数进行符号扩展<sup id="cite_ref-1" class="reference"><a href="implicit_cast.html#cite_note-1">[1]</a></sup>或截断，而对无符号数进行零扩展或截断。
</li></ul>
</dd></dl>
<ul><li> 如果目标类型有符号，那么当源整数能以目标类型表示时不会更改它的值。否则结果<span class="t-rev-inl t-until-cxx20"><span>由实现定义</span> <span><span class="t-mark-rev t-until-cxx20">(C++20 前)</span></span></span><span class="t-rev-inl t-since-cxx20"><span>等于源值模 <span class="texhtml" style="white-space: nowrap;">2<span class="t-su">n<br></span></span> 的唯一目标类型值，其中 <span class="texhtml" style="white-space: nowrap;">n</span> 用于表示目标类型的位数</span> <span><span class="t-mark-rev t-since-cxx20">(C++20 起)</span></span></span>（注意这与未定义的<a href="operator_arithmetic.html#.E6.BA.A2.E5.87.BA" title="cpp/language/operator arithmetic">有符号整数算术溢出</a>不同）。
</li><li> 如果源类型是 <span class="mw-geshi cpp source-cpp"><span class="kw4">bool</span></span>，那么值 <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw2">false</span></span></span> 转换成目标类型的零，而值 <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw2">true</span></span></span> 转换成目标类型的一（注意如果目标类型是 <span class="mw-geshi cpp source-cpp"><span class="kw4">int</span></span>，那么这是整数提升，而非整数转换）。
</li><li> 如果目标类型是 <span class="mw-geshi cpp source-cpp"><span class="kw4">bool</span></span>，那么这是<a href="implicit_cast.html#.E5.B8.83.E5.B0.94.E8.BD.AC.E6.8D.A2">布尔转换</a>（见下文）。
</li></ul>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><a href="implicit_cast.html#cite_ref-1">↑</a></span> <span class="reference-text">只有在算术是补码时才会使用，只会对<a href="../types/integer.html" title="cpp/types/integer">定宽整数类型</a>要求补码。然而注意目前所有拥有 C++ 编译器的平台都使用补码算术。</span>
</li>
</ol>
<h4><span class="mw-headline" id=".E6.B5.AE.E7.82.B9.E8.BD.AC.E6.8D.A2">浮点转换</span></h4>
<table class="t-rev-begin">
<tr class="t-rev t-until-cxx23"><td>
<p>浮点类型的<a href="value_category.html#.E7.BA.AF.E5.8F.B3.E5.80.BC" title="cpp/language/value category">纯右值</a>可转换成任意其他浮点类型的纯右值。
</p>
</td>
<td><span class="t-mark-rev t-until-cxx23">(C++23 前)</span></td></tr>
<tr class="t-rev t-since-cxx23"><td>
<p>浮点类型的<a href="value_category.html#.E7.BA.AF.E5.8F.B3.E5.80.BC" title="cpp/language/value category">纯右值</a>可转换成<a href="usual_arithmetic_conversions.html#.E6.B5.AE.E7.82.B9.E8.BD.AC.E6.8D.A2.E7.AD.89.E7.BA.A7" title="cpp/language/usual arithmetic conversions">浮点转换等级</a>更高或相等的任意其他浮点类型的纯右值。
</p><p>标准浮点类型的<a href="value_category.html#.E7.BA.AF.E5.8F.B3.E5.80.BC" title="cpp/language/value category">纯右值</a>可转换成任意其他标准浮点类型的纯右值。
</p><p>可以使用 <a href="static_cast.html" title="cpp/language/static cast"><code>static_cast</code></a> 将浮点类型的纯右值显式转换成任意其他浮点类型的纯右值。
</p>
</td>
<td><span class="t-mark-rev t-since-cxx23">(C++23 起)</span></td></tr>
</table>
<p>如果该转换列在“浮点提升”下，那么它是提升而非转换。
</p>
<ul><li> 如果源值能以目标类型精确表示，那么就不会更改它。
</li><li> 如果源值处于目标类型的两个可表示值之间，那么结果是这两个值之一（选择哪个由实现定义，不过如果支持 IEEE，那么舍入默认为<a href="../numeric/fenv/FE_round.html" title="cpp/numeric/fenv/FE round">到最接近</a>）。
</li><li> 否则，行为未定义。
</li></ul>
<h4><span class="mw-headline" id=".E6.B5.AE.E7.82.B9.E6.95.B4.E6.95.B0.E8.BD.AC.E6.8D.A2">浮点整数转换</span></h4>
<p>浮点类型的<a href="value_category.html#.E7.BA.AF.E5.8F.B3.E5.80.BC" title="cpp/language/value category">纯右值</a>可隐式转换成任意整数类型的纯右值。截断小数部分，即舍弃小数部分。
</p>
<ul><li> 如果结果不能适应到目标类型中，那么行为未定义（即使在目标类型是无符号数时，也不会实施模算术）。
</li><li> 如果目标类型是 <span class="mw-geshi cpp source-cpp"><span class="kw4">bool</span></span>，那么这是布尔转换（见<a href="implicit_cast.html#.E5.B8.83.E5.B0.94.E8.BD.AC.E6.8D.A2">下文</a>）。
</li></ul>
<p>整数或无作用域枚举类型的纯右值可转换成任意浮点类型的纯右值。结果会尽可能精确。
</p>
<ul><li> 如果该值能适应到目标类型中但不能精确表示，那么选择与之最接近的较高值还是最接近的较低值是由实现定义的，不过如果支持 IEEE，那么舍入默认为<a href="../numeric/fenv/FE_round.html" title="cpp/numeric/fenv/FE round">到最接近</a>。
</li><li> 如果该值不能适应到目标类型中，那么行为未定义。
</li><li> 如果源类型是 <span class="mw-geshi cpp source-cpp"><span class="kw4">bool</span></span>，那么值 <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw2">false</span></span></span> 转换成零，而值 <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw2">true</span></span></span> 转换成一。
</li></ul>
<h4><span class="mw-headline" id=".E6.8C.87.E9.92.88.E8.BD.AC.E6.8D.A2">指针转换</span></h4>
<p><a href="pointer.html#.E7.A9.BA.E6.8C.87.E9.92.88" title="cpp/language/pointer">空指针常量</a>能转换成任何指针类型，而结果是该类型的空指针值。允许这种转换（称为<i>空指针转换</i>）作为单次转换，转换到 cv 限定类型，即不认为它是数值和限定性转换的结合。
</p><p>指向任何（可有 cv 限定的）对象类型 <code>T</code> 的指针的<a href="value_category.html#.E7.BA.AF.E5.8F.B3.E5.80.BC" title="cpp/language/value category">纯右值</a>，可转换成指向（有相同 cv 限定的）<span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span> 的指针的纯右值。结果指针与原指针表示内存中的同一位置。
</p>
<ul><li> 如果原指针是空指针值，那么结果是目标类型的空指针值。
</li></ul>
<p>“指向（可有 cv 限定的）<code>Derived</code> 的指针”类型的纯右值 <span class="t-c"><span class="mw-geshi cpp source-cpp">ptr</span></span> 可以转换成“指向（可有 cv 限定的）<code>Base</code> 的指针”类型的纯右值，其中 <code>Base</code> 是 <code>Derived</code> 的<a href="derived_class.html" title="cpp/language/derived class">基类</a>，并且 <code>Derived</code> 是<a href="incomplete_type.html#.E4.B8.8D.E5.AE.8C.E6.95.B4.E7.B1.BB.E5.9E.8B" title="cpp/language/type">完整</a>类类型。如果 <code>Base</code> 不可访问或有歧义，那么程序非良构。
</p>
<ul><li> 如果 <span class="t-c"><span class="mw-geshi cpp source-cpp">ptr</span></span> 是空指针值，那么结果也是空指针值。
</li><li> 否则，如果 <code>Base</code> 是 <code>Derived</code> 的<a href="derived_class.html#.E8.99.9A.E5.9F.BA.E7.B1.BB" title="cpp/language/derived class">虚基类</a>，并且 <span class="t-c"><span class="mw-geshi cpp source-cpp">ptr</span></span> 没有指向类型与 <code>Derived</code> <a href="implicit_cast.html#.E7.9B.B8.E4.BC.BC.E7.B1.BB.E5.9E.8B">相似</a>且在自己的<a href="lifetime.html" title="cpp/language/lifetime">生存期</a>内或者正在构造或析构的对象，那么行为未定义。
</li><li> 否则，结果是派生类对象的基类子对象。
</li></ul>
<h4><span class="mw-headline" id=".E6.88.90.E5.91.98.E6.8C.87.E9.92.88.E8.BD.AC.E6.8D.A2">成员指针转换</span></h4>
<p><a href="pointer.html#.E7.A9.BA.E6.8C.87.E9.92.88" title="cpp/language/pointer">空指针常量</a>可转换成任何成员指针类型，而结果是该类型的空成员指针值。允许这种转换（称为<i>空成员指针转换</i>）作为单次转换，转换到 cv 限定类型，即不认为它是数值和限定性转换的结合。
</p><p>“指向 <code>Base</code> 的（可有 cv 限定的）<code>T</code> 类型成员的指针”类型的<a href="value_category.html#.E7.BA.AF.E5.8F.B3.E5.80.BC" title="cpp/language/value category">纯右值</a>可以转换成“指向 <code>Derived</code> 的（可有 cv 限定的）<code>T</code> 类型成员的指针”，其中 <code>Base</code> 是 <code>Derived</code> 的基类，并且 <code>Derived</code> 是完整类类型。如果 <code>Base</code> 是 <code>Derived</code> 的不可访问、有歧义或虚基类，或是 <code>Derived</code> 的某个中间虚基类的基类，那么程序非良构。
</p>
<ul><li> 如果 <code>Derived</code> 既没有包含该原始成员，也不是包含该原始成员的类的某个基类，那么行为未定义。
</li><li> 否则，能以 <code>Derived</code> 对象解引用结果指针，而它将访问该 <code>Derived</code> 对象的 <code>Base</code> 基类子对象内的成员。
</li></ul>
<h4><span class="mw-headline" id=".E5.B8.83.E5.B0.94.E8.BD.AC.E6.8D.A2">布尔转换</span></h4>
<p>整数、浮点、无作用域枚举、指针和成员指针类型的<a href="value_category.html#.E7.BA.AF.E5.8F.B3.E5.80.BC" title="cpp/language/value category">纯右值</a>，可转换成 <span class="mw-geshi cpp source-cpp"><span class="kw4">bool</span></span> 类型的纯右值。
</p><p>零值（对于整数、浮点和无作用域枚举）、空指针值和空成员指针值变为 <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw2">false</span></span></span>。所有其他值变为 <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw2">true</span></span></span>。
</p>
<table class="t-rev-begin">
<tr class="t-rev t-since-cxx11"><td>
<p><a href="direct_initialization.html" title="cpp/language/direct initialization">直接初始化</a>的语境中，可以 <span class="t-lc"><a href="../types/nullptr_t.html" title="cpp/types/nullptr t">std::nullptr_t</a></span> 类型的纯右值（包括 <span class="t-c"><span class="mw-geshi cpp source-cpp">nullptr</span></span>）初始化 <span class="mw-geshi cpp source-cpp"><span class="kw4">bool</span></span> 对象。结果是 <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw2">false</span></span></span>。然而不认为它是隐式转换。
</p>
</td>
<td><span class="t-mark-rev t-since-cxx11">(C++11 起)</span></td></tr>
</table>
<h3><span class="mw-headline" id=".E9.99.90.E5.AE.9A.E6.80.A7.E8.BD.AC.E6.8D.A2">限定性转换</span></h3>
<p>通常来说：
</p>
<ul><li> 指向<a href="cv.html" title="cpp/language/cv">有 cv 限定</a>的类型 <code>T</code> 的指针类型的<a href="value_category.html#.E7.BA.AF.E5.8F.B3.E5.80.BC" title="cpp/language/value category">纯右值</a>，可转换成指向有更多 cv 限定的同一类型 <code>T</code> 的指针纯右值（换言之，能添加常性和易变性）。
</li><li> 指向类 <code>X</code> 中有 cv 限定的类型 <code>T</code> 的成员指针的纯右值，可转换成指向类 <code>X</code> 中有<a href="cv.html#.E8.BD.AC.E6.8D.A2" title="cpp/language/cv">更多 cv 限定</a>的类型 <code>T</code> 的成员指针纯右值。
</li></ul>
<p>限定性转换的正式定义见<a href="implicit_cast.html#.E5.90.88.E5.B9.B6_cv_.E9.99.90.E5.AE.9A.E6.80.A7">下文</a>。
</p>
<h4><span class="mw-headline" id=".E7.9B.B8.E4.BC.BC.E7.B1.BB.E5.9E.8B">相似类型</span></h4>
<p>非正式地说，忽略顶层 cv 限定性，如果两个类型符合下列条件，那么它们<i>相似</i>：
</p>
<ul><li> 它们是同一类型；或
</li><li> 它们都是指针，且被指向的类型相似；或
</li><li> 它们都是指向相同类的成员指针，且被指向的成员类型相似；或
</li><li> 它们都是数组，且数组元素类型相似。
</li></ul>
<p>例如：
</p>
<ul><li><span class="mw-geshi cpp source-cpp"><span class="kw4">const</span> <span class="kw4">int</span><span class="sy2">*</span> <span class="kw4">const</span> <span class="sy2">*</span></span> 与 <span class="mw-geshi cpp source-cpp"><span class="kw4">int</span><span class="sy2">**</span></span> 相似；
</li><li><span class="mw-geshi cpp source-cpp"><span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span><span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="sy2">*</span><span class="br0">)</span></span> 与 <span class="mw-geshi cpp source-cpp"><span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span><span class="br0">)</span><span class="br0">(</span><span class="kw4">const</span> <span class="kw4">int</span><span class="sy2">*</span><span class="br0">)</span></span> 不相似；
</li><li><span class="mw-geshi cpp source-cpp"><span class="kw4">const</span> <span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span><span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="sy2">*</span><span class="br0">)</span></span> 与 <span class="mw-geshi cpp source-cpp"><span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span><span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="sy2">*</span><span class="br0">)</span></span> 不相似；
</li><li><span class="mw-geshi cpp source-cpp"><span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span><span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="sy2">*</span> <span class="kw4">const</span><span class="br0">)</span></span> 与 <span class="mw-geshi cpp source-cpp"><span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span><span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="sy2">*</span><span class="br0">)</span></span> 相似（它们是同一类型）；
</li><li><span class="mw-geshi cpp source-cpp"><a href="../utility/pair.html"><span class="kw1099">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span>, <span class="kw4">int</span><span class="sy1">&gt;</span></span> 与 <span class="mw-geshi cpp source-cpp"><a href="../utility/pair.html"><span class="kw1099">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><span class="kw4">const</span> <span class="kw4">int</span>, <span class="kw4">int</span><span class="sy1">&gt;</span></span> 不相似。
</li></ul>
<p>正式地说，类型的相似性基于它们的限定性分解进行定义。
</p><p>类型 <code>T</code> 的<i>限定性分解</i> ﻿是包含组分 <code>cv_i</code> 和 <code>P_i</code> 的序列，它们对于某些非负 <span class="t-c"><span class="mw-geshi cpp source-cpp">n</span></span> 可以将 <code>T</code> 分解为 “<code>cv_0 P_0 cv_1 P_1 ... cv_n−1 P_n−1 cv_n U</code>”，其中：
</p>
<ul><li> 每个 <code>cv_i</code> 都是一个可以包含 <span class="mw-geshi cpp source-cpp"><span class="kw4">const</span></span> 和 <span class="mw-geshi cpp source-cpp"><span class="kw4">volatile</span></span> 的集合。
</li><li> 每个 <code>P_i</code> 都是以下之一：
</li></ul>
<dl><dd><ul><li> “指向【某类型】的指针”。
</li><li> “指向类 <code>C_i</code> 的【某类型】成员的指针”。
</li><li> “包含 <span class="t-c"><span class="mw-geshi cpp source-cpp">N_i</span></span> 个【某类型】元素的数组”。
</li><li> “包含【某类型】元素且边界未知的数组”。
</li></ul>
</dd></dl>
<p>如果 <code>P_i</code> 指代数组，那么应用到元素类型的 cv 限定符 <code>cv_i+1</code> 也会作为引用到数组的 cv 限定符 <code>cv_i</code>。
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// T 是 “指向指向 const int 的指针的指针”，它有 3 个限定性分解：</span>
<span class="co1">// n = 0 -&gt; cv_0 为空，U 是“指向指向 const int 的指针的指针”</span>
<span class="co1">// n = 1 -&gt; cv_0 为空，P_0 是 “指向【某类型】的指针”，</span>
<span class="co1">//          cv_1 为空，U 是 “指向 const int 的指针”</span>
<span class="co1">// n = 2 -&gt; cv_0 为空，P_0 是 “指向【某类型】的指针”，</span>
<span class="co1">//          cv_1 为空，P_1 是 “指向【某类型】的指针”，</span>
<span class="co1">//          cv_2 是 “const"，U 是 “int”</span>
<span class="kw1">using</span> T <span class="sy1">=</span> <span class="kw4">const</span> <span class="kw4">int</span><span class="sy2">**</span><span class="sy4">;</span>
 
<span class="co1">// 将 U 替换为以下类型之一就可以得到一个限定性分解：</span>
<span class="co1">// U = U0 -&gt; n = 0 时的限定性分解：U0</span>
<span class="co1">// U = U1 -&gt; n = 1 时的限定性分解：指向【U1】的指针</span>
<span class="co1">// U = U2 -&gt; n = 2 时的限定性分解：指向【指向【const U2】的指针】的指针</span>
<span class="kw1">using</span> U2 <span class="sy1">=</span> <span class="kw4">int</span><span class="sy4">;</span>
<span class="kw1">using</span> U1 <span class="sy1">=</span> <span class="kw4">const</span> U2<span class="sy2">*</span><span class="sy4">;</span>
<span class="kw1">using</span> U0 <span class="sy1">=</span> U1<span class="sy2">*</span><span class="sy4">;</span></pre></div></div>
<p>对于类型 <code>T1</code> 和 <code>T2</code>，如果它们各自有一个限定性分解，使得这两个限定性分解满足以下所有条件，那么这两个类型<i>相似</i>：
</p>
<ul><li> 它们具有相同的 <span class="t-c"><span class="mw-geshi cpp source-cpp">n</span></span>。
</li><li> 它们的 <code>U</code> 指代的类型相同。
</li><li> 所有的 <span class="t-c"><span class="mw-geshi cpp source-cpp">i</span></span> 对应的每对 <code>P_i</code> 组分都各自相同<span class="t-rev-inl t-since-cxx20"><span>或者一个是“包含 <span class="t-c"><span class="mw-geshi cpp source-cpp">N_i</span></span> 个【某类型】元素的数组”而另一个是“包含【某类型】元素且边界未知的数组”</span> <span><span class="t-mark-rev t-since-cxx20">(C++20 起)</span></span></span>。
</li></ul>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// n = 2 时的限定性分解：</span>
<span class="co1">// 指向【指向【const int】的 volatile 指针】的指针</span>
<span class="kw1">using</span> T1 <span class="sy1">=</span> <span class="kw4">const</span> <span class="kw4">int</span><span class="sy2">*</span> <span class="kw4">volatile</span> <span class="sy2">*</span><span class="sy4">;</span>
 
<span class="co1">// n = 2 时的限定性分解：</span>
<span class="co1">// 指向【指向【int】的指针】的 const 指针</span>
<span class="co1">// const pointer to [pointer to [int]]</span>
<span class="kw1">using</span> T2 <span class="sy1">=</span> <span class="kw4">int</span><span class="sy2">**</span> <span class="kw4">const</span><span class="sy4">;</span>
 
<span class="co1">// 以上两个限定性分解的 cv_0、cv_1 和 cv_2 都不同，</span>
<span class="co1">// 但 n、U、P_0 和 P_1 都相同，因此 T1 和 T2 相似。</span></pre></div></div>
<h4><span class="mw-headline" id=".E5.90.88.E5.B9.B6_cv_.E9.99.90.E5.AE.9A.E6.80.A7">合并 cv 限定性</span></h4>
<p>在以下描述中，以 <code>Dn</code> 表示类型 <code>Tn</code> 的最长限定性分解，以 <code>cvn_i</code> 和 <code>Pn_i</code> 表示它的组分。
</p>
<table class="t-rev-begin">
<tr class="t-rev t-until-cxx20"><td>
<p>在满足以下所有条件时，类型是 <code>T1</code> 的纯右值表达式可以转换到类型 <code>T2</code>：
</p>
<ul><li> <code>T1</code> 和 <code>T2</code> 相似。
</li><li> 对于每个非零 <span class="t-c"><span class="mw-geshi cpp source-cpp">i</span></span>，如果 <code>cv1_i</code> 中有 <span class="mw-geshi cpp source-cpp"><span class="kw4">const</span></span>，那么 <code>cv2_i</code> 中也有 <span class="mw-geshi cpp source-cpp"><span class="kw4">const</span></span>，<span class="mw-geshi cpp source-cpp"><span class="kw4">volatile</span></span> 也是类似。
</li><li> 如果 <code>cv1_i</code> 和 <code>cv2_i</code> 不同，那么对于 <code>[</code><span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="nu0">1</span></span></span><code>, </code><span class="t-c"><span class="mw-geshi cpp source-cpp">i</span></span><code>)</code> 中的每个 <span class="t-c"><span class="mw-geshi cpp source-cpp">k</span></span>，<code>cv2_k</code> 中都有 <span class="mw-geshi cpp source-cpp"><span class="kw4">const</span></span>。
</li></ul>
<p>类型 <code>T1</code> 和 <code>T2</code> 的 <i>限定性组合类型</i> ﻿是一个与 <code>T1</code> 相似且满足以下所有条件的类型 <code>T3</code>：
</p>
<ul><li> <code>cv3_0</code> 为空。
</li><li> 对于每个非零 <span class="t-c"><span class="mw-geshi cpp source-cpp">i</span></span>，<code>cv3_i</code> 是 <code>cv1_i</code> 和 <code>cv2_i</code> 的并集。
</li><li> 如果 <code>cv3_i</code> 与 <code>cv1_i</code> 或 <code>cv2_i</code> 不同，那么对于 <code>[</code><span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="nu0">1</span></span></span><code>, </code><span class="t-c"><span class="mw-geshi cpp source-cpp">i</span></span><code>)</code> 中的每个 <span class="t-c"><span class="mw-geshi cpp source-cpp">k</span></span>，<code>cv3_k</code> 中都会加上 <span class="mw-geshi cpp source-cpp"><span class="kw4">const</span></span>。
</li></ul>
</td>
<td><span class="t-mark-rev t-until-cxx20">(C++20 前)</span></td></tr>
<tr class="t-rev t-since-cxx20"><td>
<p>类型 <code>T1</code> 和 <code>T2</code> 的<i>限定性组合类型</i> ﻿是一个与 <code>T1</code> 相似且 <code>D3</code> 满足以下所有条件的类型 <code>T3</code>：
</p>
<ul><li> 对于每个非零 <span class="t-c"><span class="mw-geshi cpp source-cpp">i</span></span>，<code>cv3_i</code> 是 <code>cv1_i</code> 和 <code>cv2_i</code> 的并集。
</li><li> 如果 <code>P1_i</code> 或 <code>P2_i</code> 是“包含【某类型】元素且边界未知的数组”，那么 <code>P3_i</code> 是“包含【某类型】元素且边界未知的数组”，否则它是 <code>P1_i</code>。
</li><li> 如果 <code>cv3_i</code> 与 <code>cv1_i</code> 或 <code>cv2_i</code> 不同，或者 <code>P3_i</code> 与 <code>P1_i</code> 或 <code>P2_i</code> 不同，那么对于 <code>[</code><span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="nu0">1</span></span></span><code>, </code><span class="t-c"><span class="mw-geshi cpp source-cpp">i</span></span><code>)</code> 中的每个 <span class="t-c"><span class="mw-geshi cpp source-cpp">k</span></span>，<code>cv3_k</code> 中都会加上 <span class="mw-geshi cpp source-cpp"><span class="kw4">const</span></span>。
</li></ul>
<p>如果类型 <code>T1</code> 和 <code>T2</code> 的限定性组合类型是无 cv 限定的 <code>T2</code>，那么类型是 <code>T1</code> 的纯右值可以转换到 <code>T2</code>。
</p>
</td>
<td><span class="t-mark-rev t-since-cxx20">(C++20 起)</span></td></tr>
</table>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// T1 的最长限定性分解（n = 2）：</span>
<span class="co1">// 指向【指向【char】的指针】的指针</span>
<span class="kw1">using</span> T1 <span class="sy1">=</span> <span class="kw4">char</span><span class="sy2">**</span><span class="sy4">;</span>
 
<span class="co1">// T2 的最长限定性分解（n = 2）：</span>
<span class="co1">// 指向【指向【const char】的指针】的指针</span>
<span class="kw1">using</span> T2 <span class="sy1">=</span> <span class="kw4">const</span> <span class="kw4">char</span><span class="sy2">**</span><span class="sy4">;</span>
 
<span class="co1">// 确定 D3 的 cv3_i 和 T_i 组分（n = 2）：</span>
<span class="co1">// cv3_1 = 空（空 cv1_1 和空 cv2_1 的并集）</span>
<span class="co1">// cv3_2 = “const”（空 cv1_2 和 “const” cv2_2 的并集）</span>
<span class="co1">// P3_0 = “指向【某类型】的指针”（没有边界未知的数组，因此采用 P1_0）</span>
<span class="co1">// P3_1 = “指向【某类型】的指针”（没有边界未知的数组，因此采用 P1_1）</span>
<span class="co1">// cv_2 以外的组分都相同，但 cv3_2 与 cv1_2 不同，</span>
<span class="co1">// 因此对于 [1, 2) 中的每个 k，都会向 cv3_k 中添加 “const”：cv3_1 会变成 “const”。</span>
<span class="co1">// T3 是“指向指向 const char 的 const 指针的指针”，即 const char* const *。</span>
<span class="kw1">using</span> T3 <span class="sy1">=</span> <span class="coMULTI">/* T1 和 T2 的限定性组合类型 */</span><span class="sy4">;</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">const</span> <span class="kw4">char</span> c <span class="sy1">=</span> <span class="st0">'c'</span><span class="sy4">;</span>
    <span class="kw4">char</span><span class="sy2">*</span> pc<span class="sy4">;</span>
    T1 ppc <span class="sy1">=</span> <span class="sy3">&amp;</span>pc<span class="sy4">;</span>
    T2 pcc <span class="sy1">=</span> ppc<span class="sy4">;</span> <span class="co1">// 错误：T3 与 无 cv 限定的 T2 不同，无法进行限定性转换。</span>
 
    <span class="sy2">*</span>pcc <span class="sy1">=</span> <span class="sy3">&amp;</span>c<span class="sy4">;</span>
    <span class="sy2">*</span>pc <span class="sy1">=</span> <span class="st0">'C'</span><span class="sy4">;</span> <span class="co1">// 如果允许上述错误赋值，那么就可以修改 const 对象 “c”，</span>
<span class="br0">}</span></pre></div></div>
<p>注意在 C 编程语言中，只能添加 <span class="mw-geshi cpp source-cpp"><span class="kw4">const</span></span>/<span class="mw-geshi cpp source-cpp"><span class="kw4">volatile</span></span> 到第一级：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">char</span><span class="sy2">**</span> p <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="kw4">char</span> <span class="sy2">*</span> <span class="kw4">const</span><span class="sy2">*</span> p1 <span class="sy1">=</span> p<span class="sy4">;</span>       <span class="co1">// C 与 C++ 中 OK</span>
<span class="kw4">const</span> <span class="kw4">char</span><span class="sy2">*</span> <span class="kw4">const</span> <span class="sy2">*</span> p2 <span class="sy1">=</span> p<span class="sy4">;</span> <span class="co1">// C 中错误，C++ 中 OK</span></pre></div></div>
<table class="t-rev-begin">
<tr class="t-rev t-since-cxx17"><td>
<h3> <span class="mw-headline" id=".E5.87.BD.E6.95.B0.E6.8C.87.E9.92.88.E8.BD.AC.E6.8D.A2">函数指针转换</span></h3>
<ul><li> 指向无抛出函数的指针类型的<a href="value_category.html#.E7.BA.AF.E5.8F.B3.E5.80.BC" title="cpp/language/value category">纯右值</a>，可转换成指向潜在抛出函数的指针纯右值。
</li><li> 指向无抛出成员函数指针类型的纯右值，可转换成指向潜在抛出成员函数的指针纯右值。
</li></ul>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">void</span> <span class="br0">(</span><span class="sy2">*</span>p<span class="br0">)</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="kw4">void</span> <span class="br0">(</span><span class="sy2">**</span>pp<span class="br0">)</span><span class="br0">(</span><span class="br0">)</span> <span class="kw1">noexcept</span> <span class="sy1">=</span> <span class="sy3">&amp;</span>p<span class="sy4">;</span> <span class="co1">// 错误：不能转换成指向 noexcept 函数的指针</span>
 
<span class="kw1">struct</span> S
<span class="br0">{</span>
    <span class="kw1">typedef</span> <span class="kw4">void</span> <span class="br0">(</span><span class="sy2">*</span>p<span class="br0">)</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    operator p<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
<span class="kw4">void</span> <span class="br0">(</span><span class="sy2">*</span>q<span class="br0">)</span><span class="br0">(</span><span class="br0">)</span> <span class="kw1">noexcept</span> <span class="sy1">=</span> S<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 错误：不能转换成指向 noexcept 函数的指针</span></pre></div></div>
</td>
<td><span class="t-mark-rev t-since-cxx17">(C++17 起)</span></td></tr>
</table>
<h3><span class="mw-headline" id=".E5.AE.89.E5.85.A8_bool_.E9.97.AE.E9.A2.98">安全 bool 问题</span></h3>
<p>在 C++11 前，设计一个能用于布尔语境的类（比如，<span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">if</span> <span class="br0">(</span>obj<span class="br0">)</span> <span class="br0">{</span> ... <span class="br0">}</span></span></span>）会出现问题：给定一个用户定义转换函数，如 <span class="t-c"><span class="mw-geshi cpp source-cpp">T<span class="sy4">::</span><span class="me2">operator</span> <span class="kw4">bool</span><span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span><span class="sy4">;</span></span></span>，那么隐式转换序列允许再多一步标准转换序列，也就是 <span class="mw-geshi cpp source-cpp"><span class="kw4">bool</span></span> 结果会转换成 <span class="mw-geshi cpp source-cpp"><span class="kw4">int</span></span>，允许诸如 <span class="t-c"><span class="mw-geshi cpp source-cpp">obj <span class="sy1">&lt;&lt;</span> <span class="nu0">1</span><span class="sy4">;</span></span></span> 或 <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">int</span> i <span class="sy1">=</span> obj<span class="sy4">;</span></span></span> 这样的代码。
</p><p>一个早期的解决方案可参见 <span class="t-lc"><a href="../io/basic_ios.html" title="cpp/io/basic ios">std::basic_ios</a></span>，它最初定义了 <span class="mw-geshi cpp source-cpp">operator <span class="kw4">void</span><span class="sy2">*</span></span>，使得如 <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">if</span> <span class="br0">(</span><a href="../io/cin.html"><span class="kw1760">std::<span class="me2">cin</span></span></a><span class="br0">)</span> <span class="br0">{</span>...<span class="br0">}</span></span></span> 的代码能编译，因为 <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span><span class="sy2">*</span></span> 能转换到 <span class="mw-geshi cpp source-cpp"><span class="kw4">bool</span></span>，但 <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">int</span> n <span class="sy1">=</span> <a href="../io/cout.html"><span class="kw1762">std::<span class="me2">cout</span></span></a><span class="sy4">;</span></span></span> 不能，因为 <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span><span class="sy2">*</span></span> 不可转换到 <span class="mw-geshi cpp source-cpp"><span class="kw4">int</span></span>。这仍然允许无意义代码能编译，如 <span class="t-c"><span class="mw-geshi cpp source-cpp">delete <a href="../io/cout.html"><span class="kw1762">std::<span class="me2">cout</span></span></a><span class="sy4">;</span></span></span>。
</p><p>许多 C++11 前的第三方库设计带有更为复杂的解决方案，称作<a rel="nofollow" class="external text" href="http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Safe_bool">安全 Bool 手法</a>。<span class="t-lc"><a href="../io/basic_ios.html" title="cpp/io/basic ios">std::basic_ios</a></span> 也通过 <a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue468">LWG 问题 468</a> 允许该手法，并替换了 <span class="mw-geshi cpp source-cpp">operator <span class="kw4">void</span><span class="sy2">*</span></span>（见<a href="../io/basic_ios/operator_bool.html#.E6.B3.A8.E8.A7.A3" title="cpp/io/basic ios/operator bool">此处</a>）。
</p><p>从 C++11 起，<a href="explicit.html" title="cpp/language/explicit">显式 bool 转换</a>可以解决安全 bool 问题。
</p>
<h3><span class="mw-headline" id=".E7.BC.BA.E9.99.B7.E6.8A.A5.E5.91.8A">缺陷报告</span></h3>
<p>下列更改行为的缺陷报告追溯地应用于以前出版的 C++ 标准。
</p>
<table class="dsctable" style="font-size:0.8em">
<tr>
<th> 缺陷报告
</th>
<th> 应用于
</th>
<th> 出版时的行为
</th>
<th> 正确行为
</th></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/170.html">CWG 170</a>
</td>
<td> C++98
</td>
<td> 成员指针转换在派生类不含原始成员时的行为不明确
</td>
<td> 使之明确
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/172.html">CWG 172</a>
</td>
<td> C++98
</td>
<td> 枚举类型的提升基于它的底层类型
</td>
<td> 改为基于它的值范围
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/330.html">CWG 330</a><br>(<a rel="nofollow" class="external text" href="https://wg21.link/N4261">N4261</a>)
</td>
<td> C++98
</td>
<td> 从 <span class="mw-geshi cpp source-cpp"><span class="kw4">double</span> <span class="sy2">*</span> <span class="kw4">const</span> <span class="br0">(</span><span class="sy2">*</span>p<span class="br0">)</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span></span> 到<br><span class="mw-geshi cpp source-cpp"><span class="kw4">double</span> <span class="kw4">const</span> <span class="sy2">*</span> <span class="kw4">const</span> <span class="br0">(</span><span class="sy2">*</span>p<span class="br0">)</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span></span> 的转换非法
</td>
<td> 转换合法
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/519.html">CWG 519</a>
</td>
<td> C++98
</td>
<td> 空指针值在转换到其他指针类型后不保证会保留
</td>
<td> 总会保留
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/616.html">CWG 616</a>
</td>
<td> C++98
</td>
<td> 任何未初始化对象和拥有非法值的指针对象<br>的左值到右值的转换的行为都未定义
</td>
<td> 允许不定值的 <span class="mw-geshi cpp source-cpp"><span class="kw4">unsigned</span> <span class="kw4">char</span></span>；<br>使用非法指针的行为由实现定义
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/685.html">CWG 685</a>
</td>
<td> C++98
</td>
<td> 提升底层类型固定的枚举类型时不会优先提升到底层类型
</td>
<td> 此时优先提升到底层类型
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/707.html">CWG 707</a>
</td>
<td> C++98
</td>
<td> 整数到浮点转换在所有情况下的行为都有定义
</td>
<td> 在值超出目标类型的值域时行为未定义
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1423.html">CWG 1423</a>
</td>
<td> C++11
</td>
<td> <span class="t-lc"><a href="../types/nullptr_t.html" title="cpp/types/nullptr t">std::nullptr_t</a></span> 在直接或复制初始化中可转换到 <span class="mw-geshi cpp source-cpp"><span class="kw4">bool</span></span>
</td>
<td> 只允许直接初始化
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1773.html">CWG 1773</a>
</td>
<td> C++11
</td>
<td> 对于在潜在求值表达式中出现的名字表达式，即使没有 ODR 使用<br>被命名的对象，该表达式依然有有可能在左值到右值转换中被求值
</td>
<td> 此时不求值该表达式
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1781.html">CWG 1781</a>
</td>
<td> C++11
</td>
<td> <span class="t-lc"><a href="../types/nullptr_t.html" title="cpp/types/nullptr t">std::nullptr_t</a></span> 到 <span class="mw-geshi cpp source-cpp"><span class="kw4">bool</span></span> 被认为是<br>隐式转换，尽管只对直接初始化合法
</td>
<td> 不再认为它是隐式转换
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1787.html">CWG 1787</a>
</td>
<td> C++98
</td>
<td> 读取缓存在寄存器中的中间 <span class="mw-geshi cpp source-cpp"><span class="kw4">unsigned</span> <span class="kw4">char</span></span> 是未定义行为
</td>
<td> 赋予它良好定义
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1981.html">CWG 1981</a>
</td>
<td> C++11
</td>
<td> 按语境转换会考虑显式转换函数
</td>
<td> 不会考虑
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2140.html">CWG 2140</a>
</td>
<td> C++11
</td>
<td> 不明确从 <span class="t-lc"><a href="../types/nullptr_t.html" title="cpp/types/nullptr t">std::nullptr_t</a></span> 左值进行的<br>左值到右值转换是否会从内存中获取该左值
</td>
<td> 不会从内存中获取
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2310.html">CWG 2310</a>
</td>
<td> C++98
</td>
<td> 派生类到基类的指针转换和基类到派生类的<br>成员指针转换不需要派生类是完整类型
</td>
<td> 必须是完整类型
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2484.html">CWG 2484</a>
</td>
<td> C++20
</td>
<td> <span class="mw-geshi cpp source-cpp">char8_t</span> 与 <span class="mw-geshi cpp source-cpp"><span class="kw4">char16_t</span></span> 的整数提升<br>策略不同，但它们都能用这两个策略
</td>
<td> <span class="mw-geshi cpp source-cpp">char8_t</span> 与 <span class="mw-geshi cpp source-cpp"><span class="kw4">char16_t</span></span><br>的整数提升方法一致
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2485.html">CWG 2485</a>
</td>
<td> C++98
</td>
<td> 涉及位域的整数提升的描述不够好
</td>
<td> 改进描述
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2813.html">CWG 2813</a>
</td>
<td> C++23
</td>
<td> 调用类纯右值的显式对象成员函数时会发生临时量实质化
</td>
<td> 不会发生临时量实质化
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2861.html">CWG 2861</a>
</td>
<td> C++98
</td>
<td> 指向类型不可访问的对象的指针可以转换成指向基类子对象的指针
</td>
<td> 此时行为未定义
</td></tr></table>
<h3><span class="mw-headline" id=".E5.8F.82.E9.98.85">参阅</span></h3>
<ul><li> <a href="const_cast.html" title="cpp/language/const cast"><code>const_cast</code></a>
</li><li> <a href="static_cast.html" title="cpp/language/static cast"><code>static_cast</code></a>
</li><li> <a href="dynamic_cast.html" title="cpp/language/dynamic cast"><code>dynamic_cast</code></a>
</li><li> <a href="reinterpret_cast.html" title="cpp/language/reinterpret cast"><code>reinterpret_cast</code></a>
</li><li> <a href="explicit_cast.html" title="cpp/language/explicit cast">显式转换</a>
</li><li> <a href="cast_operator.html" title="cpp/language/cast operator">用户定义转换</a>
</li></ul>
<table class="t-dsc-begin">

</table>

<!-- 
NewPP limit report
Preprocessor visited node count: 11549/1000000
Preprocessor generated node count: 20326/1000000
Post‐expand include size: 230087/4194304 bytes
Template argument size: 52058/4194304 bytes
Highest expansion depth: 16/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_zh_:pcache:idhash:2722-0!*!0!!zh!*!zh!* and timestamp 20240824114629 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    来自“<a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/language/implicit_conversion&amp;oldid=93568">https://zh.cppreference.com/mwiki/index.php?title=cpp/language/implicit_conversion&amp;oldid=93568</a>”                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        <div id="cpp-footer-base" class="noprint">
            <div id="footer">
                        <div id="cpp-navigation">
            <h5>导航</h5>
            <ul><li><a href="https://zh.cppreference.com/w/cpp/language/implicit_conversion">Online version</a></li><li>Offline version retrieved 2024-09-15 16:01.</li></ul></div>
                        <ul id="footer-info">
                                    <li id="footer-info-lastmod"> 本页面最后修改于2024年8月21日 (星期三) 00:45。</li>
                            </ul>
                    </div>
        </div>
        <!-- /footer -->
        <script>if(window.mw){
mw.loader.state({"site":"loading","user":"missing","user.groups":"ready"});
}</script>
<script src="../../../common/skin_scripts.js"></script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.page.ready","mediawiki.searchSuggest","mediawiki.hidpi","ext.gadget.MathJax","ext.gadget.ColiruCompiler"], null, true);
}</script>
<script src="../../../common/site_scripts.js"></script>
<!-- Served in 0.046 secs. -->
	</body>
<!-- Cached 20240824193222 -->
</html>